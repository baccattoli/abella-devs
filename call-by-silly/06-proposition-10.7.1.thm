Import "05-def-of-structural-reductions-for-call-by-silly".

%%%%%
%% Postponement of str_red_app wrt exponential steps
%%%%%

Theorem str_red_app_root_str_red_app_strong_postponement_e : forall T T' U, 
   str_red_app_root T' T -> ctx_cl_tm red_root_e T U 
   -> exists U', ctx_cl_tm red_root_e T' U' /\ str_red_app U' U.
induction on 2. intros. case H2.
    case H3. case H1. case H4.
        apply free_oc_ctx_absurd to H5.
        search.
    case H1.
    case H1.
    case H1 (keep). apply e_step_shape to H3.  apply red_e_does_not_create_free_names2 to H3. apply e_step_esub_extension to H3 with A = S. search.
    case H1 (keep). search.

Theorem str_red_app_and_freeoc : forall T S C A, nabla x,  
    str_red_app (T x) (S x) -> 
    free_oc_ctx (S x) x (C x) -> 
        exists D, free_oc_ctx (T x) x D /\ str_red_app (D A) (C x A).
induction on 1. intros. case H1 (keep).
    case H3. case H2 (keep).
        search.
        case H4.
            apply free_oc_ctx_does_not_create_free_names to H5.
            search.
            search.
    search.
    apply IH to H4 H2 with A = A. apply IH to H3 H5 with A = A. search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.
    case H2.
        apply IH to H3 H4 with A = A. search.
        search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.
    case H2.
        apply IH to H3 H4 with A = A. search.
        search.

Theorem str_red_app_and_freeoc_subst : forall T S C U, nabla x,  
    free_oc_ctx (T x) x (C x) -> 
    str_red_app U S -> str_red_app (C x U) (C x S).
induction on 1. intros. case H1.
    search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.

Theorem str_red_app_strong_postponement_e : forall T T' U, 
   str_red_app T' T -> ctx_cl_tm red_root_e T U 
   -> exists U', ctx_cl_tm red_root_e T' U' /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    apply str_red_app_root_str_red_app_strong_postponement_e to H3 H2. search.
    search.
    apply IH to H4 H2. apply IH to H3 H5. search.
    case H2 (keep). 
        case H4. apply str_red_app_and_freeoc to H3 H5 with A = U1. search.
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4. apply str_red_app_and_freeoc_subst to H5 H3. search.
        search.
        apply IH to H3 H4. search.
    case H2.
        case H4.
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4.
        search.
        apply IH to H3 H4. search.


%%%%%
%% Postponement of str_red_app wrt multiplicative steps
%%%%%

Theorem str_red_app_abs_impossible : forall T U,
    str_red_app T (abs U) -> T = abs U.
induction on 1. intros. case H1.
    case H2.
    search.
    apply IH to H3. apply IH to H2. search.

Theorem strong_postponement_root_m_left_of_app : forall S U S' T,
    str_red_app T S ->
    red_root_m (app S U) S' -> exists T', red_root_m (app T U) T' /\ str_red_app T' S'.
induction on 1. intros. case H2 (keep).
    apply str_red_app_abs_impossible to H1. search.
    case H1.
        case H4. case H3.
        search.
        apply IH to H5 H2. apply IH to H4 H6. search.
        apply IH to H4 H3. search.
        search.
    
Theorem strong_postponement_root_m_right_of_app : forall S U S' T,
    str_red_app T U ->
    red_root_m (app S U) S' -> exists T', red_root_m (app S T) T' /\ str_red_app T' S'.
induction on 2. intros. case H2 (keep).
    search.
    apply IH to H1 H3. search.


Theorem str_red_app_strong_postponement_m : forall T T' U, 
   str_red_app T' T -> ctx_cl_tm red_root_m T U 
   -> exists U', ctx_cl_tm red_root_m T' U' /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    case H2.
        case H4.
            case H3.
            case H3.
        case H3.
        case H3.
        case H3. case H4.
            case H5.
                search.
                search.
            search.
            apply red_m_does_not_create_free_names to H5. search.
        case H3. search.
    search.
    apply IH to H4 H2. apply IH to H3 H5. search.
    case H2 (keep). 
        case H4. 
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4.
        search.
        apply IH to H3 H4. search.
    case H2.
        apply strong_postponement_root_m_left_of_app to H3 H4. search. 
        apply IH to H3 H4. search.
        search.
    case H2.
        apply strong_postponement_root_m_right_of_app to H3 H4. search.
        search.
        apply IH to H3 H4. search.

%%%%%
%% Postponement of str_red_ans wrt exponential steps
%%%%%

Theorem str_red_ans_root_strong_postponement_e : forall T T' U, 
   str_red_ans_root T' T -> ctx_cl_tm red_root_e T U 
   -> exists U', ctx_cl_tm red_root_e T' U' /\ str_red_ans_root U' U.
intros. case H1 (keep). case H2.
    case H4. case H5.
        search.
        apply free_oc_ctx_absurd to H6.
    case H4.
        case H5. permute (n1 n2) H3. apply free_oc_ctx_answer_absurd to H3 H7 with x = n2.
        permute (n1 n2) H3. apply is_answer_does_not_e_reduce to H3 H5.
        search.
    search.

Theorem str_red_ans_freeoc : forall T S C A, nabla x,  
    str_red_ans (T x) (S x) -> 
    free_oc_ctx (S x) x (C x) -> 
        exists D, free_oc_ctx (T x) x D /\ str_red_ans (D A) (C x A).
induction on 1. intros. case H1.
    case H3.
        case H2.
            search.
            case H5.
                search.
                permute (n2 n3) H4. apply free_oc_ctx_answer_absurd to H4 H6.
        search.
        case H2.
            search.
            apply IH to H3 H4 with A = A. search.


Theorem str_red_ans_strong_postponement_e : forall T T' U, 
   str_red_ans T' T -> ctx_cl_tm red_root_e T U 
   -> exists U', ctx_cl_tm red_root_e T' U' /\ str_red_ans U' U.
induction on 1. intros. case H1 (keep).
    apply str_red_ans_root_strong_postponement_e to H3 H2. search.
    search.
    case H2 (keep).
        case H4. apply str_red_ans_freeoc to H3 H5 with A = U1. search.
        apply IH  to H3 H4. search.
        search.
        

%%%%%
%% Postponement of str_red_ans wrt multiplicative steps
%%%%%

Theorem str_red_ans_strong_postponement_m : forall T T' U, 
   str_red_ans T' T -> ctx_cl_tm red_root_m T U 
   -> exists U', ctx_cl_tm red_root_m T' U' /\ str_red_ans U' U.
induction on 1. intros. case H1 (keep).
    case H3. case H2.
        case H5.
        case H5.
            case H6.
            permute (n1 n2) H4. apply is_answer_does_not_m_reduce to H4 H6.
            search.
        search.
    search.
    case H2.
        case H4.
        apply IH to H3 H4. search.
        search.
