Import "02-def-of-structural-reduction-app-for-call-by-name".

%%%%%%%
%%%%%%%

Theorem str_red_app_root_str_red_app_strong_postponement_e : forall T T' U, 
   str_red_app_root T' T -> ctx_cl_tm red_root_e T U 
   -> exists U', ctx_cl_tm red_root_e T' U' /\ str_red_app U' U.
induction on 2. intros. case H2.
    case H3. case H1. case H4.
        apply free_oc_ctx_absurd to H5.
        search.
    case H1.
    case H1.
    case H1 (keep). apply e_step_shape to H3.  apply red_e_does_not_create_free_names2 to H3. apply e_step_esub_extension to H3 with A = S. search.
    case H1 (keep). search.

Theorem str_red_app_and_freeoc : forall T S C A, nabla x,  
    str_red_app (T x) (S x) -> 
    free_oc_ctx (S x) x (C x) -> 
        exists D, free_oc_ctx (T x) x D /\ str_red_app (D A) (C x A).
induction on 1. intros. case H1 (keep).
    case H3. case H2 (keep).
        search.
        case H4.
            apply free_oc_ctx_does_not_create_free_names to H5.
            search.
            search.
    search.
    apply IH to H4 H2 with A = A. apply IH to H3 H5 with A = A. search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.


Theorem str_red_app_strong_postponement_e : forall T T' U, 
   str_red_app T' T -> ctx_cl_tm red_root_e T U 
   -> exists U', ctx_cl_tm red_root_e T' U' /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    apply str_red_app_root_str_red_app_strong_postponement_e to H3 H2. search.
    search.
    apply IH to H4 H2. apply IH to H3 H5. search.
    case H2 (keep). 
        case H4. apply str_red_app_and_freeoc to H3 H5 with A = U1. search.
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4.
        apply IH to H3 H4. search.
        search.


Theorem red_m_does_not_create_free_names : forall T (U : tm -> tm), nabla x, 
    ctx_cl_tm red_root_m T (U x) -> exists S, nabla y, S = U y.
induction on 1. intros. case H1.
    apply red_root_m_does_not_create_free_names to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.

        
Theorem str_red_app_abs_impossible : forall T U,
    str_red_app T (abs U) -> T = abs U.
induction on 1. intros. case H1.
    case H2.
    search.
    apply IH to H3. apply IH to H2. search.

Theorem strong_postponement_root_m_left_of_app : forall S U S' T,
    str_red_app T S ->
    red_root_m (app S U) S' -> exists T', red_root_m (app T U) T' /\ str_red_app T' S'.
induction on 1. intros. case H2 (keep).
    apply str_red_app_abs_impossible to H1. search.
    case H1.
        case H4. case H3.
        search.
        apply IH to H5 H2. apply IH to H4 H6. search. 
        apply IH to H4 H3. search.


Theorem str_red_app_strong_postponement_m : forall T T' U, 
   str_red_app T' T -> ctx_cl_tm red_root_m T U 
   -> exists U', ctx_cl_tm red_root_m T' U' /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    case H2.
        case H4.
            case H3.
            case H3.
        case H3.
        case H3.
        case H3. case H4.
            case H5.
                search.
                search.
            search.
            apply red_m_does_not_create_free_names to H5. search.
        case H3. search.
    search.
    apply IH to H4 H2. apply IH to H3 H5. search.
    case H2 (keep). 
        case H4. 
        apply IH to H3 H4. search.
        search.
    case H2.
        apply strong_postponement_root_m_left_of_app to H3 H4. search. 
        apply IH to H3 H4. search.
        search.
