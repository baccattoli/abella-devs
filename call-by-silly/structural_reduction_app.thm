Kind tm type.

%lsc terms
Type abs (tm -> tm) -> tm.
Type app tm -> tm -> tm.
Type esub (tm -> tm) -> tm -> tm.

Set witnesses on.

%%%%%%%%%%
%%
%%  Micro Weak Head Reduction
%%
%%%%%%%%%%

Define red_root_db : tm -> tm -> prop by
    red_root_db (app (abs T) U) (esub T U);
    red_root_db (app (esub T S) U) (esub V S) 
    		:= nabla x, red_root_db (app (T x) U) (V x).

Define free_oc : tm -> tm -> prop by
    nabla x, free_oc x x;
    nabla x, free_oc (app (T x) (U x)) x := nabla x, free_oc (U x) x;
    nabla x, free_oc (app (T x) (U x)) x := nabla x, free_oc (T x) x;
    nabla x, free_oc (esub (T x) (U x)) x := nabla x, free_oc (U x) x;
    nabla x, free_oc (esub (T x) (U x)) x := nabla x y, free_oc (T x y) x;
    nabla x, free_oc (abs (T x)) x :=  nabla x y, free_oc (T x y) x.

Define single_hole_ctx : (tm -> tm) -> prop by
    single_hole_ctx (h\h);
    single_hole_ctx (h\ abs (x\ C x h)) := nabla x, single_hole_ctx (C x);
    single_hole_ctx (h\ app (C h) U) := single_hole_ctx C;
    single_hole_ctx (h\ app U (C h)) := single_hole_ctx C;
    single_hole_ctx (h\ esub (x\ C x h) U) := nabla x, single_hole_ctx (C x);
    single_hole_ctx (h\ esub U (C h)) := single_hole_ctx C.

Define free_oc_ctx : tm -> tm -> (tm -> tm) -> prop by
    nabla x, free_oc_ctx x x (h\h);
    nabla x, free_oc_ctx (app (T x) (U x)) x (h\ app (T x) (C x h)) := nabla x, free_oc_ctx (U x) x (C x);
    nabla x, free_oc_ctx (app (T x) (U x)) x (h\ app (C x h) (U x)) := nabla x, free_oc_ctx (T x) x (C x);
    nabla x, free_oc_ctx (esub (T x) (U x)) x (h\ esub (T x) (C x h)) := nabla x, free_oc_ctx (U x) x (C x);
    nabla x, free_oc_ctx (esub (T x) (U x)) x (h\ esub (C x h) (U x)) := nabla x y, free_oc_ctx (T x y) x (h\ C x h y).


Theorem free_oc_ctx_is_well_defined : forall T C, nabla x,
    free_oc_ctx (T x) x (C x) -> T x = C x x.
induction on 1. intros. case H1.
    search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.

Define red_root_ms      : tm -> tm -> prop  by
    red_root_ms (esub T U) (esub (x\ C x U) U) :=
    nabla x, free_oc_ctx (T x) x (C x).

Define ctx_cl_tm : (tm -> tm -> prop) -> (tm -> tm -> prop) by
    ctx_cl_tm R T U := R T U;
    ctx_cl_tm R (app T S) (app U S) := ctx_cl_tm R T U;
    ctx_cl_tm R (app S T) (app S U) := ctx_cl_tm R T U;
    ctx_cl_tm R (esub T S) (esub U S) := 
      nabla x, ctx_cl_tm R (T x) (U x);
    ctx_cl_tm R (esub S T ) (esub S U) := 
      ctx_cl_tm R (T) (U).

Define red_mwh : tm -> tm -> prop  by
    red_mwh T U := ctx_cl_tm red_root_ms T U;
    red_mwh T U := ctx_cl_tm red_root_db T U.

Define is_answer : tm -> prop by
    is_answer (abs T);
    is_answer (esub T U) := nabla x, is_answer (T x).

/*Define ms_normal  : tm -> prop  by
    ms_normal T := is_answer T;
    nabla x, ms_normal (T x) := nabla x, free_head_var (T x) x;
    ms_normal T := exists U, ctx_cl_tm red_root_db T U.
*/


%%%%%%%%%
% STRUCTURAL REDUCTION APP
%%%%%%%%%

Define str_red_app_root : tm -> tm -> prop by
	str_red_app_root (app (esub (x\T x) U) S) (esub (x\app (T x) S) U).

Define str_red_app : tm -> tm -> prop by
    /* injection of the root case */
    str_red_app P Q := str_red_app_root P Q;  

    /* equivalence relation clauses */
    str_red_app P P; % this case is needed for the postponement of db steps
    str_red_app P R := exists Q, str_red_app P Q /\ str_red_app Q R;  

    /* contextual closure clauses */
    str_red_app (esub T U) (esub S U) := nabla x, str_red_app (T x) (S x);
    str_red_app (esub U T) (esub U S) := str_red_app T S;
    str_red_app (app T U) (app S U) := str_red_app T S;
    str_red_app (app U T) (app U S) := str_red_app T S.

%%%%%%%
%%%%%%%

Theorem free_oc_ctx_absurd : forall T C, nabla x,
    free_oc_ctx T x (C x) -> false.
induction on 1. intros. case H1 (keep).
    apply IH to H2.
    apply IH to H2.
    apply IH to H2.
    apply IH to H2.

Theorem ms_step_shape : forall T U S,
ctx_cl_tm red_root_ms (app T U) S -> 
    exists T' U', S = app T' U'.
induction on 1. intros. case H1 (keep).
    case H2.
    search.
    search.


Theorem ms_step_es_extension : forall T U T' U' A, nabla x,
ctx_cl_tm red_root_ms (app (T x) U) (app (T' x) U') -> 
    ctx_cl_tm red_root_ms (app (esub T A) U) (app (esub T' A) U').
induction on 1. intros. case H1 (keep).
    case H2. 
    search.
    search.
    

Theorem free_oc_ctx_does_not_create_free_names : forall T (C : tm -> tm -> tm -> tm), nabla x y,
    free_oc_ctx (T x) x (C y x) -> exists D, nabla y', D = C y'.
induction on 1. intros. case H1 (keep).
    search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.


Theorem red_ms_does_not_create_free_names : forall T (U : tm -> tm), nabla x, 
    ctx_cl_tm red_root_ms T (U x) -> exists S, nabla y, S = U y.
induction on 1. intros. case H1.
    case H2. apply free_oc_ctx_does_not_create_free_names to H4. search.
    apply IH to H2 with x = n1. search.
    apply IH to H2 with x = n1. search.
    apply IH to H2 with x = n1. search.
    apply IH to H2 with x = n1. search.


Theorem red_ms_does_not_create_free_names2 : forall (T : tm -> tm) T' U U', nabla x, 
    ctx_cl_tm red_root_ms (app (T x) U) (app (T' x) (U' x)) -> 
        exists S, nabla y, S = U' y.
intros. case H1.
    case H2.
    search.
    apply red_ms_does_not_create_free_names to H2. search.


Theorem str_red_app_root_str_red_app_strong_postponement_ms : forall T T' U, 
   str_red_app_root T' T -> ctx_cl_tm red_root_ms T U 
   -> exists U', ctx_cl_tm red_root_ms T' U' /\ str_red_app U' U.
induction on 2. intros. case H2.
    case H3. case H1. case H4.
        apply free_oc_ctx_absurd to H5.
        search.
    case H1.
    case H1.
    case H1 (keep). apply ms_step_shape to H3.  apply red_ms_does_not_create_free_names2 to H3. apply ms_step_es_extension to H3 with A = S. search.
    case H1 (keep). search.

Theorem str_red_app_and_freeoc : forall T S C A, nabla x,  
    str_red_app (T x) (S x) -> 
    free_oc_ctx (S x) x (C x) -> 
        exists D, free_oc_ctx (T x) x D /\ str_red_app (D A) (C x A).
induction on 1. intros. case H1 (keep).
    case H3. case H2 (keep).
        search.
        case H4.
            apply free_oc_ctx_does_not_create_free_names to H5.
            search.
            search.
    search.
    apply IH to H4 H2 with A = A. apply IH to H3 H5 with A = A. search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.
    case H2.
        apply IH to H3 H4 with A = A. search.
        search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.
    case H2.
        apply IH to H3 H4 with A = A. search.
        search.

Theorem str_red_app_and_freeoc_subst : forall T S C U, nabla x,  
    free_oc_ctx (T x) x (C x) -> 
    str_red_app U S -> str_red_app (C x U) (C x S).
induction on 1. intros. case H1.
    search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.

Theorem str_red_app_strong_postponement_ms : forall T T' U, 
   str_red_app T' T -> ctx_cl_tm red_root_ms T U 
   -> exists U', ctx_cl_tm red_root_ms T' U' /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    apply str_red_app_root_str_red_app_strong_postponement_ms to H3 H2. search.
    search.
    apply IH to H4 H2. apply IH to H3 H5. search.
    case H2 (keep). 
        case H4. apply str_red_app_and_freeoc to H3 H5 with A = U1. search.
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4. apply str_red_app_and_freeoc_subst to H5 H3. search.
        search.
        apply IH to H3 H4. search.
    case H2.
        case H4.
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4.
        search.
        apply IH to H3 H4. search.


Theorem red_root_db_does_not_create_free_names : forall T (U : tm -> tm), nabla x, 
    red_root_db T (U x) -> exists S, nabla y, S = U y.
induction on 1. intros. case H1.
    search.
    apply IH to H2. search.


Theorem red_db_does_not_create_free_names : forall T (U : tm -> tm), nabla x, 
    ctx_cl_tm red_root_db T (U x) -> exists S, nabla y, S = U y.
induction on 1. intros. case H1.
    apply red_root_db_does_not_create_free_names to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.

        
Theorem str_red_app_abs_impossible : forall T U,
    str_red_app T (abs U) -> T = abs U.
induction on 1. intros. case H1.
    case H2.
    search.
    apply IH to H3. apply IH to H2. search.

Theorem strong_postponement_root_db_left_of_app : forall S U S' T,
    str_red_app T S ->
    red_root_db (app S U) S' -> exists T', red_root_db (app T U) T' /\ str_red_app T' S'.
induction on 1. intros. case H2 (keep).
    apply str_red_app_abs_impossible to H1. search.
    case H1.
        case H4. case H3.
        search.
        apply IH to H5 H2. apply IH to H4 H6. search.
        apply IH to H4 H3. search.
        search.
    
Theorem strong_postponement_root_db_right_of_app : forall S U S' T,
    str_red_app T U ->
    red_root_db (app S U) S' -> exists T', red_root_db (app S T) T' /\ str_red_app T' S'.
induction on 2. intros. case H2 (keep).
    search.
    apply IH to H1 H3. search.


Theorem str_red_app_strong_postponement_db : forall T T' U, 
   str_red_app T' T -> ctx_cl_tm red_root_db T U 
   -> exists U', ctx_cl_tm red_root_db T' U' /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    case H2.
        case H4.
            case H3.
            case H3.
        case H3.
        case H3.
        case H3. case H4.
            case H5.
                search.
                search.
            search.
            apply red_db_does_not_create_free_names to H5. search.
        case H3. search.
    search.
    apply IH to H4 H2. apply IH to H3 H5. search.
    case H2 (keep). 
        case H4. 
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4.
        search.
        apply IH to H3 H4. search.
    case H2.
        apply strong_postponement_root_db_left_of_app to H3 H4. search. 
        apply IH to H3 H4. search.
        search.
    case H2.
        apply strong_postponement_root_db_right_of_app to H3 H4. search.
        search.
        apply IH to H3 H4. search.