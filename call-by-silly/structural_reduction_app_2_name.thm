Kind tm type.

%lsc terms
Type abs (tm -> tm) -> tm.
Type app tm -> tm -> tm.
Type esub (tm -> tm) -> tm -> tm.

Set witnesses on.

%%%%%%%%%%
%%
%%  Micro Weak Head Reduction
%%
%%%%%%%%%%

Define red_root_db : tm -> tm -> prop by
    red_root_db (app (abs T) U) (esub T U);
    red_root_db (app (esub T S) U) (esub V S) 
    		:= nabla x, red_root_db (app (T x) U) (V x).

Define free_oc : tm -> tm -> prop by
    nabla x, free_oc x x;
    nabla x, free_oc (app (T x) (U x)) x := nabla x, free_oc (U x) x;
    nabla x, free_oc (app (T x) (U x)) x := nabla x, free_oc (T x) x;
    nabla x, free_oc (esub (T x) (U x)) x := nabla x, free_oc (U x) x;
    nabla x, free_oc (esub (T x) (U x)) x := nabla x y, free_oc (T x y) x;
    nabla x, free_oc (abs (T x)) x :=  nabla x y, free_oc (T x y) x.

Define single_hole_ctx : (tm -> tm) -> prop by
    single_hole_ctx (h\h);
    single_hole_ctx (h\ abs (x\ C x h)) := nabla x, single_hole_ctx (C x);
    single_hole_ctx (h\ app (C h) U) := single_hole_ctx C;
    single_hole_ctx (h\ app U (C h)) := single_hole_ctx C;
    single_hole_ctx (h\ esub (x\ C x h) U) := nabla x, single_hole_ctx (C x);
    single_hole_ctx (h\ esub U (C h)) := single_hole_ctx C.

Define free_oc_ctx : tm -> tm -> (tm -> tm) -> prop by
    nabla x, free_oc_ctx x x (h\h);
    nabla x, free_oc_ctx (app (T x) (U x)) x (h\ app (T x) (C x h)) := nabla x, free_oc_ctx (U x) x (C x);
    nabla x, free_oc_ctx (app (T x) (U x)) x (h\ app (C x h) (U x)) := nabla x, free_oc_ctx (T x) x (C x);
    nabla x, free_oc_ctx (esub (T x) (U x)) x (h\ esub (T x) (C x h)) := nabla x, free_oc_ctx (U x) x (C x);
    nabla x, free_oc_ctx (esub (T x) (U x)) x (h\ esub (C x h) (U x)) := nabla x y, free_oc_ctx (T x y) x (h\ C x h y).


Theorem free_oc_ctx_is_well_defined : forall T C, nabla x,
    free_oc_ctx (T x) x (C x) -> T x = C x x.
induction on 1. intros. case H1.
    search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.

Define red_root_ms      : tm -> tm -> prop  by
    red_root_ms (esub T U) (esub (x\ C x U) U) :=
    nabla x, free_oc_ctx (T x) x (C x).

Define ctx_cl_tm : (tm -> tm -> prop) -> (tm -> tm -> prop) by
    ctx_cl_tm R T U := R T U;
    ctx_cl_tm R (app T S) (app U S) := ctx_cl_tm R T U;
    ctx_cl_tm R (app S T) (app S U) := ctx_cl_tm R T U;
    ctx_cl_tm R (esub T S) (esub U S) := 
      nabla x, ctx_cl_tm R (T x) (U x);
    ctx_cl_tm R (esub S T ) (esub S U) := 
      ctx_cl_tm R (T) (U).

Define red_mwh : tm -> tm -> prop  by
    red_mwh T U := ctx_cl_tm red_root_ms T U;
    red_mwh T U := ctx_cl_tm red_root_db T U.

Define is_answer : tm -> prop by
    is_answer (abs T);
    is_answer (esub T U) := nabla x, is_answer (T x).

/*Define ms_normal  : tm -> prop  by
    ms_normal T := is_answer T;
    nabla x, ms_normal (T x) := nabla x, free_head_var (T x) x;
    ms_normal T := exists U, ctx_cl_tm red_root_db T U.
*/


%%%%%%%%%
% STRUCTURAL REDUCTION APP
%%%%%%%%%

Define str_red_app_root : tm -> tm -> prop by
	str_red_app_root (app (esub (x\T x) U) S) (esub (x\app (T x) S) U).

Define str_red_app : tm -> tm -> prop by
    /* injection of the root case */
    str_red_app P Q := str_red_app_root P Q;  

    /* equivalence relation clauses */
    str_red_app P P; % this case is needed for the postponement of db steps
    str_red_app P R := exists Q, str_red_app P Q /\ str_red_app Q R;  

    /* contextual closure clauses */
    str_red_app (esub T U) (esub S U) := nabla x, str_red_app (T x) (S x);
    str_red_app (app T U) (app S U) := str_red_app T S.


%%%%%%%
%%%%%%%

Theorem str_red_app_root_strong_postponement_ms2 : forall T T' U', 
   str_red_app_root T' T -> ctx_cl_tm red_root_ms T' U' 
   -> exists U, ctx_cl_tm red_root_ms T U /\ str_red_app U' U.
induction on 2. intros. case H2.
    case H1. case H3.
    case H1 (keep). case H3.
        case H4. search.
        search.
        search.
    case H1. case H3.
        case H4. search.
        search.
        search.
        search.
        search.
    case H1.
    case H1.

Theorem str_red_app_and_freeoc2 : forall T S C A, nabla x,  
    str_red_app (T x) (S x) -> 
    free_oc_ctx (T x) x (C x) -> 
        exists D, free_oc_ctx (S x) x D /\ str_red_app (C x A) (D A).
induction on 1. intros. case H1 (keep).
    case H3. case H2 (keep).
        search.
        case H4.
            search.
            search.
    search.
    apply IH to H3 H2 with A = A. apply IH to H4 H5 with A = A. search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.
    case H2.
        search.
        apply IH to H3 H4 with A = A. search.


Theorem str_red_app_strong_postponement_ms : forall T T' U', 
   str_red_app T' T -> ctx_cl_tm red_root_ms T' U' 
   -> exists U, ctx_cl_tm red_root_ms T U /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    apply str_red_app_root_strong_postponement_ms2 to H3 H2. search.
    search.
    apply IH to H3 H2. apply IH to H4 H5. search.
    case H2 (keep). 
        case H4.  apply str_red_app_and_freeoc2 to H3 H5 with A = U. search.
        apply IH to H3 H4. search.
        search.
    case H2.
        case H4.
        apply IH to H3 H4. search.
        search.

        
Theorem str_red_app_abs_impossible2 : forall T U,
    str_red_app (abs T) U -> U = abs T.
induction on 1. intros. case H1.
    case H2.
    search.
    apply IH to H2. apply IH to H3. search.

Theorem strong_postponement_root_db_left_of_app2 : forall S U T T',
    str_red_app T S ->
    red_root_db (app T U) T' -> exists S', red_root_db (app S U) S' /\ str_red_app T' S'.
induction on 1. intros. case H2 (keep).
    apply str_red_app_abs_impossible2 to H1. search.
    case H1.
        case H4.
        search.
        apply IH to H4 H2. apply IH to H5 H6. search.
        apply IH to H4 H3. search.


Theorem str_red_app_strong_postponement_db : forall T T' U',
   str_red_app T' T -> ctx_cl_tm red_root_db T' U' 
   -> exists U, ctx_cl_tm red_root_db T U /\ str_red_app U' U.
induction on 1. intros. case H1 (keep).
    case H2 (keep).
        case H3. case H4. search.
        case H3. case H4.
            case H5.
            search.
            search.
        case H3. search.
        case H3.
        case H3.
    search.
    apply IH to H3 H2. apply IH to H4 H5. search.
    case H2 (keep). 
        case H4. 
        apply IH to H3 H4. search.
        search.
    case H2.
        apply strong_postponement_root_db_left_of_app2 to H3 H4. search. 
        apply IH to H3 H4. search.
        search.
        