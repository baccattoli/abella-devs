Kind tm type.

%lsc terms
Type abs (tm -> tm) -> tm.
Type app tm -> tm -> tm.
Type esub (tm -> tm) -> tm -> tm.

Set witnesses on.

%%%%%%%%%%
%%
%%  Micro Weak Head Reduction
%%
%%%%%%%%%%

Define red_root_db : tm -> tm -> prop by
    red_root_db (app (abs T) U) (esub T U);
    red_root_db (app (esub T S) U) (esub V S) 
    		:= nabla x, red_root_db (app (T x) U) (V x).

Define free_oc : tm -> tm -> prop by
    nabla x, free_oc x x;
    nabla x, free_oc (app (T x) (U x)) x := nabla x, free_oc (U x) x;
    nabla x, free_oc (app (T x) (U x)) x := nabla x, free_oc (T x) x;
    nabla x, free_oc (esub (T x) (U x)) x := nabla x, free_oc (U x) x;
    nabla x, free_oc (esub (T x) (U x)) x := nabla x y, free_oc (T x y) x;
    nabla x, free_oc (abs (T x)) x :=  nabla x y, free_oc (T x y) x.

Define single_hole_ctx : (tm -> tm) -> prop by
    single_hole_ctx (h\h);
    single_hole_ctx (h\ abs (x\ C x h)) := nabla x, single_hole_ctx (C x);
    single_hole_ctx (h\ app (C h) U) := single_hole_ctx C;
    single_hole_ctx (h\ app U (C h)) := single_hole_ctx C;
    single_hole_ctx (h\ esub (x\ C x h) U) := nabla x, single_hole_ctx (C x);
    single_hole_ctx (h\ esub U (C h)) := single_hole_ctx C.

Define free_oc_ctx : tm -> tm -> (tm -> tm) -> prop by
    nabla x, free_oc_ctx x x (h\h);
    nabla x, free_oc_ctx (app (T x) (U x)) x (h\ app (T x) (C x h)) := nabla x, free_oc_ctx (U x) x (C x);
    nabla x, free_oc_ctx (app (T x) (U x)) x (h\ app (C x h) (U x)) := nabla x, free_oc_ctx (T x) x (C x);
    nabla x, free_oc_ctx (esub (T x) (U x)) x (h\ esub (T x) (C x h)) := nabla x, free_oc_ctx (U x) x (C x);
    nabla x, free_oc_ctx (esub (T x) (U x)) x (h\ esub (C x h) (U x)) := nabla x y, free_oc_ctx (T x y) x (h\ C x h y).


Theorem free_oc_ctx_is_well_defined : forall T C, nabla x,
    free_oc_ctx (T x) x (C x) -> T x = C x x.
induction on 1. intros. case H1.
    search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.

Define red_root_ms : tm -> tm -> prop  by
    red_root_ms (esub T U) (esub (x\ C x U) U) :=
    nabla x, free_oc_ctx (T x) x (C x).

Define ctx_cl_tm : (tm -> tm -> prop) -> (tm -> tm -> prop) by
    ctx_cl_tm R T U := R T U;
    ctx_cl_tm R (app T S) (app U S) := ctx_cl_tm R T U;
    ctx_cl_tm R (app S T) (app S U) := ctx_cl_tm R T U;
    ctx_cl_tm R (esub T S) (esub U S) := 
      nabla x, ctx_cl_tm R (T x) (U x);
    ctx_cl_tm R (esub S T ) (esub S U) := 
      ctx_cl_tm R (T) (U).

Define is_answer : tm -> prop by
    is_answer (abs T);
    is_answer (esub T U) := is_answer U /\ nabla x, is_answer (T x).


%%%%%%%%%
% STRUCTURAL REDUCTION APP
%%%%%%%%%

Define str_red_ans_root : tm -> tm -> prop by
	str_red_ans_root (esub A (esub T U)) (esub (x\ esub A (T x)) U) := nabla x, is_answer (A x).

Define str_red_ans : tm -> tm -> prop by
    /* injection of the root case */
    str_red_ans P Q := str_red_ans_root P Q;  

    /* equivalence relation clauses */
    %str_red_app P P; % this case is needed for the postponement of db steps
    %str_red_ans P R := exists Q, str_red_app P Q /\ str_red_app Q R;  

    /* contextual closure clauses */
    str_red_ans (esub T U) (esub S U) := nabla x, str_red_ans (T x) (S x).
    %str_red_app (esub U T) (esub U S) := str_red_app T S;
    %str_red_app (app T U) (app S U) := str_red_app T S;
    %str_red_app (app U T) (app U S) := str_red_app T S.

%%%%%%%
%%%%%%%

Theorem free_oc_ctx_absurd : forall T C, nabla x,
    free_oc_ctx T x (C x) -> false.
induction on 1. intros. case H1 (keep).
    apply IH to H2.
    apply IH to H2.
    apply IH to H2.
    apply IH to H2.

Theorem free_oc_ctx_answer_absurd : forall A C, nabla x,
    is_answer (A x) -> 
    free_oc_ctx (A x) x (C x) -> false.
induction on 1. intros. case H1.
    case H2.
    case H2.
        apply IH to H3 H5.
        apply IH to H4 H5.

Theorem is_answer_does_not_root_ms_reduce : forall A U,
    is_answer A -> red_root_ms A U -> false.
induction on 1. intros. case H1.
    case H2.
    case H2. apply free_oc_ctx_answer_absurd to H4 H5.

Theorem is_answer_does_not_ms_reduce : forall A U,
    is_answer A -> ctx_cl_tm red_root_ms A U -> false.
induction on 2. intros. case H2.
    apply is_answer_does_not_root_ms_reduce to H1 H3.
    case H1.
    case H1.
    case H1. apply IH to H5 H3.
    case H1. apply IH to H4 H3.


Theorem str_red_ans_root_strong_postponement_ms : forall T T' U, 
   str_red_ans_root T' T -> ctx_cl_tm red_root_ms T U 
   -> exists U', ctx_cl_tm red_root_ms T' U' /\ str_red_ans_root U' U.
intros. case H1 (keep). case H2.
    case H4. case H5.
        search.
        apply free_oc_ctx_absurd to H6.
    case H4.
        case H5. permute (n1 n2) H3. apply free_oc_ctx_answer_absurd to H3 H7 with x = n2.
        permute (n1 n2) H3. apply is_answer_does_not_ms_reduce to H3 H5.
        search.
    search.

Theorem str_red_ans_freeoc : forall T S C A, nabla x,  
    str_red_ans (T x) (S x) -> 
    free_oc_ctx (S x) x (C x) -> 
        exists D, free_oc_ctx (T x) x D /\ str_red_ans (D A) (C x A).
induction on 1. intros. case H1.
    case H3.
        case H2.
            search.
            case H5.
                search.
                permute (n2 n3) H4. apply free_oc_ctx_answer_absurd to H4 H6.
        case H2.
            search.
            apply IH to H3 H4 with A = A. search.


Theorem str_red_ans_strong_postponement_ms : forall T T' U, 
   str_red_ans T' T -> ctx_cl_tm red_root_ms T U 
   -> exists U', ctx_cl_tm red_root_ms T' U' /\ str_red_ans U' U.
induction on 1. intros. case H1 (keep).
    apply str_red_ans_root_strong_postponement_ms to H3 H2. search.
    case H2 (keep).
        case H4. apply str_red_ans_freeoc to H3 H5 with A = U1. search.
        apply IH  to H3 H4. search.
        search.
        

Theorem is_answer_does_not_db_reduce : forall A U,
    is_answer A -> ctx_cl_tm red_root_db A U -> false.
induction on 2. intros. case H2.
    case H1.
        case H3.
        case H3.
    case H1.
    case H1.
    case H1. apply IH to H5 H3.
    case H1. apply IH to H4 H3.

Theorem str_red_ans_strong_postponement_ms : forall T T' U, 
   str_red_ans T' T -> ctx_cl_tm red_root_db T U 
   -> exists U', ctx_cl_tm red_root_db T' U' /\ str_red_ans U' U.
induction on 1. intros. case H1 (keep).
    case H3. case H2.
        case H5.
        case H5.
            case H6.
            permute (n1 n2) H4. apply is_answer_does_not_db_reduce to H4 H6.
            search.
        search.
    case H2.
        case H4.
        apply IH to H3 H4. search.
        search.
